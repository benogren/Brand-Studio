#!/usr/bin/env python3
"""
Interactive CLI for AI Brand Studio.

This module provides a command-line interface for generating brand names
using the ADK-based multi-agent orchestrator system.
"""

import argparse
import json
import os
import sys
import time
from typing import Dict, Any
from dotenv import load_dotenv

# ADK imports
from google.adk.runners import InMemoryRunner
from google.adk.apps.app import App, EventsCompactionConfig
from google.adk.plugins.logging_plugin import LoggingPlugin

# Brand Studio imports
from src.agents.orchestrator import create_orchestrator


def create_parser() -> argparse.ArgumentParser:
    """
    Create and configure the argument parser.

    Returns:
        Configured ArgumentParser instance
    """
    parser = argparse.ArgumentParser(
        description='AI Brand Studio - Generate legally-clear, SEO-optimized brand names',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive mode
  python -m src.cli

  # Direct input
  python -m src.cli --product "AI meal planning app" --audience "Busy parents" --personality warm

  # With JSON output
  python -m src.cli --product "Fintech app" --json output.json
        """
    )

    # Product information
    parser.add_argument(
        '--product',
        '-p',
        type=str,
        help='Product description (what does your product do?)'
    )

    parser.add_argument(
        '--audience',
        '-a',
        type=str,
        default='',
        help='Target audience (who is this product for?)'
    )

    parser.add_argument(
        '--personality',
        '-P',
        type=str,
        choices=['playful', 'professional', 'innovative', 'luxury'],
        default='professional',
        help='Brand personality (default: professional)'
    )

    parser.add_argument(
        '--industry',
        '-i',
        type=str,
        default='general',
        help='Industry/category (e.g., healthcare, fintech, food_tech)'
    )

    # Output options
    parser.add_argument(
        '--json',
        '-j',
        type=str,
        metavar='FILE',
        help='Save result to JSON file'
    )

    parser.add_argument(
        '--verbose',
        '-v',
        action='store_true',
        help='Verbose output'
    )

    return parser


def load_config() -> Dict[str, str]:
    """
    Load configuration from environment variables.

    Returns:
        Dictionary with configuration values
    """
    load_dotenv()

    project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
    location = os.getenv('GOOGLE_CLOUD_LOCATION', 'us-central1')

    if not project_id:
        raise ValueError(
            "GOOGLE_CLOUD_PROJECT environment variable is required. "
            "Please configure your .env file."
        )

    return {
        'project_id': project_id,
        'location': location
    }


def get_interactive_input() -> Dict[str, str]:
    """
    Get user input interactively.

    Returns:
        Dictionary with user inputs
    """
    print("\n" + "=" * 70)
    print("AI BRAND STUDIO - INTERACTIVE MODE")
    print("=" * 70 + "\n")

    product = input("Product description: ").strip()
    if not product:
        raise ValueError("Product description is required")

    audience = input("Target audience (optional): ").strip()

    print("\nBrand personality options:")
    print("  1. Playful")
    print("  2. Professional (default)")
    print("  3. Innovative")
    print("  4. Luxury")
    personality_choice = input("Choose (1-4, default=2): ").strip()

    personality_map = {
        '1': 'playful',
        '2': 'professional',
        '3': 'innovative',
        '4': 'luxury',
        '': 'professional'
    }
    personality = personality_map.get(personality_choice, 'professional')

    industry = input("Industry (optional, e.g., healthcare, fintech): ").strip() or 'general'

    return {
        'product': product,
        'audience': audience,
        'personality': personality,
        'industry': industry
    }


def build_prompt(inputs: Dict[str, str]) -> str:
    """
    Build a prompt for the orchestrator from user inputs.

    Args:
        inputs: Dictionary with user inputs

    Returns:
        Formatted prompt string
    """
    prompt = f"""
Create a complete brand identity for the following product:

Product Description: {inputs['product']}

Target Audience: {inputs.get('audience') or 'General consumers'}

Brand Personality: {inputs['personality']}

Industry: {inputs['industry']}

Please generate:
1. Research insights about the industry and competitive landscape
2. 20-50 creative brand name candidates
3. Validation results for domain/trademark availability
4. SEO optimization including meta title and description
5. Brand story with taglines and positioning
"""
    return prompt.strip()


def print_result(result: Any, verbose: bool = False) -> None:
    """
    Print the result in a formatted way.

    Args:
        result: Result from the Runner
        verbose: Whether to show verbose output
    """
    print("\n" + "=" * 70)
    print("BRAND IDENTITY GENERATED")
    print("=" * 70)

    if isinstance(result, str):
        print("\n" + result)
    elif isinstance(result, dict):
        if verbose:
            print("\n" + json.dumps(result, indent=2))
        else:
            print("\n" + json.dumps(result, indent=2)[:500] + "...")
            print("\nUse --verbose to see full output or --json to save to file")
    else:
        print("\n" + str(result))

    print("\n" + "=" * 70)


def main():
    """Main CLI entry point."""
    parser = create_parser()
    args = parser.parse_args()

    try:
        # Load configuration
        config = load_config()

        # Get user inputs
        if args.product:
            # Use command-line arguments
            inputs = {
                'product': args.product,
                'audience': args.audience,
                'personality': args.personality,
                'industry': args.industry
            }
        else:
            # Interactive mode
            inputs = get_interactive_input()

        # Build prompt
        prompt = build_prompt(inputs)

        if args.verbose:
            print("\n" + "-" * 70)
            print("CONFIGURATION")
            print("-" * 70)
            print(f"Project: {config['project_id']}")
            print(f"Location: {config['location']}")
            print("\nPrompt:")
            print(prompt)
            print("-" * 70)

        # Create orchestrator - use agent directly without App wrapper
        print("\nInitializing AI Brand Studio...")
        orchestrator = create_orchestrator()

        # Use agent directly with InMemoryRunner (simpler, avoids session issues)
        runner = InMemoryRunner(agent=orchestrator)
        print("✓ Ready\n")

        # Execute
        print("Generating brand identity...")
        print("(This may take a few minutes as agents research and validate names)\n")

        # Use run_debug (async method)
        import asyncio

        async def run_agent():
            events = await runner.run_debug(
                user_messages=prompt,
                quiet=False,
                verbose=args.verbose
            )
            return events

        try:
            events = asyncio.run(run_agent())

            # Extract final result from events
            result = None
            for event in events:
                if hasattr(event, 'content') and event.content:
                    result = event.content

            if result is None:
                result = "No response generated"

        except Exception as e:
            print(f"\n❌ Error during execution: {e}")
            if args.verbose:
                import traceback
                traceback.print_exc()
            result = f"Error: {e}"

        # Display result
        print_result(result, verbose=args.verbose)

        # Save to JSON if requested
        if args.json:
            with open(args.json, 'w') as f:
                if isinstance(result, str):
                    json.dump({"result": result}, f, indent=2)
                elif isinstance(result, dict):
                    json.dump(result, f, indent=2)
                else:
                    json.dump({"result": str(result)}, f, indent=2)
            print(f"\n✓ Result saved to: {args.json}")

        sys.exit(0)

    except ValueError as e:
        print(f"\n❌ Error: {e}")
        sys.exit(1)

    except KeyboardInterrupt:
        print("\n\n✗ Interrupted by user")
        sys.exit(1)

    except Exception as e:
        print(f"\n❌ Unexpected Error: {e}")
        if args.verbose if hasattr(args, 'verbose') else False:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
