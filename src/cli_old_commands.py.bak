#!/usr/bin/env python3
"""
Interactive CLI for AI Brand Studio with session-based workflow.

Implements the multi-step interactive workflow:
1. generate - Generate initial brand names (10-20)
2. feedback - Provide feedback and regenerate
3. validate - Run SEO, domain, trademark checks
4. story - Generate brand story for selected names

Based on ADK Day 3 session patterns from coursework.
"""

import argparse
import sys
import os
from typing import Dict, Any
from dotenv import load_dotenv

# ADK imports
from google.adk.runners import InMemoryRunner

# Brand Studio imports
from src.agents.research_agent import create_research_agent
from src.agents.name_generator import create_name_generator_agent
from src.agents.validation_agent import create_validation_agent
from src.agents.seo_agent import create_seo_agent
from src.agents.story_agent import create_story_agent
from src.infrastructure.session_manager import get_session_manager, BrandSessionState


def create_parser() -> argparse.ArgumentParser:
    """
    Create CLI argument parser with subcommands.

    Returns:
        Configured ArgumentParser
    """
    parser = argparse.ArgumentParser(
        description='AI Brand Studio - Interactive Session-Based Workflow',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Start new session and generate names
  python -m src.cli_interactive generate \\
    --session my-brand \\
    --product "AI fitness app" \\
    --personality innovative

  # Provide feedback and regenerate
  python -m src.cli_interactive feedback \\
    --session my-brand \\
    --feedback "I like tech-focused names" \\
    --keep "KinetiCore,Evolve.AI"

  # Validate selected names
  python -m src.cli_interactive validate \\
    --session my-brand \\
    --names "KinetiCore,Evolve.AI,IntelliFit"

  # Generate brand story
  python -m src.cli_interactive story \\
    --session my-brand \\
    --name "KinetiCore"

  # List all sessions
  python -m src.cli_interactive list

  # Show session status
  python -m src.cli_interactive status --session my-brand
        """
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # Generate command
    gen_parser = subparsers.add_parser('generate', help='Generate initial brand names')
    gen_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')
    gen_parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    gen_parser.add_argument('--product', '-p', required=True, help='Product description')
    gen_parser.add_argument('--audience', '-a', default='General consumers', help='Target audience')
    gen_parser.add_argument('--personality', '-P', required=True,
                           choices=['playful', 'professional', 'innovative', 'luxury'],
                           help='Brand personality')
    gen_parser.add_argument('--industry', '-i', default='general', help='Industry/category')
    gen_parser.add_argument('--count', '-c', type=int, default=15, help='Number of names (default: 15)')

    # Feedback command
    feedback_parser = subparsers.add_parser('feedback', help='Provide feedback and regenerate')
    feedback_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')
    feedback_parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    feedback_parser.add_argument('--feedback', '-f', required=True, help='Your feedback')
    feedback_parser.add_argument('--keep', '-k', help='Comma-separated names you like')
    feedback_parser.add_argument('--count', '-c', type=int, default=15, help='Number of new names')

    # Validate command
    validate_parser = subparsers.add_parser('validate', help='Validate selected names')
    validate_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')
    validate_parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    validate_parser.add_argument('--names', '-n', required=True,
                                help='Comma-separated names to validate')

    # Story command
    story_parser = subparsers.add_parser('story', help='Generate brand story')
    story_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')
    story_parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    story_parser.add_argument('--name', '-n', required=True, help='Final brand name')

    # Status command
    status_parser = subparsers.add_parser('status', help='Show session status')
    status_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')

    # Show command
    show_parser = subparsers.add_parser('show', help='Show generated names and results')
    show_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')
    show_parser.add_argument('--format', choices=['simple', 'detailed', 'json'], default='simple',
                            help='Output format (default: simple)')

    # List command
    subparsers.add_parser('list', help='List all sessions')

    # Delete command
    delete_parser = subparsers.add_parser('delete', help='Delete session')
    delete_parser.add_argument('--session', '-s', type=str, required=True, help='Session ID')

    return parser


def load_config() -> Dict[str, str]:
    """Load configuration from environment."""
    load_dotenv()

    project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
    location = os.getenv('GOOGLE_CLOUD_LOCATION', 'us-central1')

    if not project_id:
        raise ValueError(
            "GOOGLE_CLOUD_PROJECT environment variable is required. "
            "Please configure your .env file."
        )

    return {
        'project_id': project_id,
        'location': location
    }


def cmd_generate(args, session: BrandSessionState, config: Dict[str, str]) -> None:
    """
    Generate initial brand names.

    Args:
        args: Command arguments
        session: Session state
        config: Environment config
    """
    print("\n" + "=" * 70)
    print("GENERATE BRAND NAMES")
    print("=" * 70 + "\n")

    # Store product info
    session.set_product_info(
        product=args.product,
        audience=args.audience,
        personality=args.personality,
        industry=args.industry
    )

    # Step 1: Run research agent
    print("Step 1/2: Running research agent...")
    research_agent = create_research_agent()
    research_runner = InMemoryRunner(agent=research_agent)

    research_prompt = f"""
Analyze the following product for brand naming:

Product: {args.product}
Audience: {args.audience}
Personality: {args.personality}
Industry: {args.industry}

Provide research insights in JSON format.
"""

    import asyncio

    async def run_research():
        events = await research_runner.run_debug(
            user_messages=research_prompt,
            quiet=not args.verbose,
            verbose=args.verbose
        )
        return events

    events = asyncio.run(run_research())

    # Extract research insights from events
    research_insights = None
    for event in events:
        if hasattr(event, 'content') and event.content:
            research_insights = event.content
            break

    if research_insights:
        session.set_research_insights({'raw_output': str(research_insights)})
        print("âœ“ Research complete\n")
    else:
        print("âœ— Research failed\n")
        return

    # Step 2: Generate names
    print(f"Step 2/2: Generating {args.count} brand names...")
    name_generator = create_name_generator_agent()
    name_runner = InMemoryRunner(agent=name_generator)

    name_prompt = f"""
Based on the research insights, generate {args.count} creative brand names for:

Product: {args.product}
Personality: {args.personality}
Industry: {args.industry}

Return as JSON array with: name, strategy, rationale, strength_score
"""

    async def run_generator():
        events = await name_runner.run_debug(
            user_messages=name_prompt,
            quiet=not args.verbose,
            verbose=args.verbose
        )
        return events

    events = asyncio.run(run_generator())

    # Extract names - look for text content in events
    names_output = []
    for event in events:
        # Check if event has text parts
        if hasattr(event, 'content'):
            content = event.content
            # If content is a string, use it
            if isinstance(content, str):
                names_output.append(content)
            # If content has parts, extract text
            elif hasattr(content, 'parts'):
                for part in content.parts:
                    if hasattr(part, 'text') and part.text:
                        names_output.append(part.text)
        # Also check if event itself has 'text' attribute
        elif hasattr(event, 'text') and event.text:
            names_output.append(event.text)

    if names_output:
        # Join all text outputs
        full_output = '\n\n'.join(names_output)
        session.add_generated_names([{'raw_output': full_output}], replace=True)
        print(f"âœ“ Generated {args.count} names\n")
    else:
        print("âœ— Name generation failed (no text output found)\n")
        return

    # Save session
    get_session_manager().save_session(session)

    print("=" * 70)
    print("âœ“ NAME GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nSession: {session.session_id}")
    print(f"Generated: {args.count} names")
    print("\nNext steps:")
    print(f"  1. Review names: python -m src.cli_interactive show --session {session.session_id}")
    print(f"  2. Provide feedback: python -m src.cli_interactive feedback --session {session.session_id} --feedback \"your feedback\"")
    print(f"  3. Or validate names: python -m src.cli_interactive validate --session {session.session_id} --names \"Name1,Name2,Name3\"")
    print()


def cmd_feedback(args, session: BrandSessionState, config: Dict[str, str]) -> None:
    """
    Provide feedback and regenerate names.

    Args:
        args: Command arguments
        session: Session state
        config: Environment config
    """
    print("\n" + "=" * 70)
    print("REGENERATE WITH FEEDBACK")
    print("=" * 70 + "\n")

    # Parse kept names
    kept_names = []
    if args.keep:
        kept_names = [n.strip() for n in args.keep.split(',')]

    # Store feedback
    session.add_feedback(feedback=args.feedback, liked_names=kept_names)

    product_info = session.get_product_info()

    print(f"Feedback: {args.feedback}")
    if kept_names:
        print(f"Keeping: {', '.join(kept_names)}")
    print()

    print(f"Generating {args.count} new names based on feedback...")

    # Generate new names with feedback context
    name_generator = create_name_generator_agent()
    name_runner = InMemoryRunner(agent=name_generator)

    feedback_context = f"""
Previous names you liked: {', '.join(kept_names) if kept_names else 'None'}
Your feedback: {args.feedback}
"""

    name_prompt = f"""
Generate {args.count} NEW brand names incorporating this feedback:

{feedback_context}

Product: {product_info.get('product', 'Unknown')}
Personality: {product_info.get('personality', 'Unknown')}
Industry: {product_info.get('industry', 'Unknown')}

Return as JSON array with: name, strategy, rationale, strength_score
"""

    import asyncio

    async def run_generator():
        events = await name_runner.run_debug(
            user_messages=name_prompt,
            quiet=not args.verbose,
            verbose=args.verbose
        )
        return events

    events = asyncio.run(run_generator())

    # Extract names - look for text content in events
    names_output = []
    for event in events:
        # Check if event has text parts
        if hasattr(event, 'content'):
            content = event.content
            # If content is a string, use it
            if isinstance(content, str):
                names_output.append(content)
            # If content has parts, extract text
            elif hasattr(content, 'parts'):
                for part in content.parts:
                    if hasattr(part, 'text') and part.text:
                        names_output.append(part.text)
        # Also check if event itself has 'text' attribute
        elif hasattr(event, 'text') and event.text:
            names_output.append(event.text)

    if names_output:
        # Join all text outputs
        full_output = '\n\n'.join(names_output)
        session.add_generated_names([{'raw_output': full_output}], replace=False)
        print(f"âœ“ Generated {args.count} new names\n")
    else:
        print("âœ— Name generation failed (no text output found)\n")
        return

    # Save session
    get_session_manager().save_session(session)

    print("=" * 70)
    print("âœ“ REGENERATION COMPLETE")
    print("=" * 70)
    print(f"\nSession: {session.session_id}")
    print(f"\nNext steps:")
    print(f"  1. Review new names")
    print(f"  2. Provide more feedback or validate")
    print()


def cmd_validate(args, session: BrandSessionState, config: Dict[str, str]) -> None:
    """
    Validate selected names.

    Args:
        args: Command arguments
        session: Session state
        config: Environment config
    """
    print("\n" + "=" * 70)
    print("VALIDATE BRAND NAMES")
    print("=" * 70 + "\n")

    # Parse names
    names_to_validate = [n.strip() for n in args.names.split(',')]
    session.set_selected_names(names_to_validate)

    print(f"Validating {len(names_to_validate)} names:")
    for name in names_to_validate:
        print(f"  - {name}")
    print()

    # Run validation agent
    print("Running validation checks (domain, trademark, SEO, search)...")
    validation_agent = create_validation_agent()
    validation_runner = InMemoryRunner(agent=validation_agent)

    validation_prompt = f"""
Validate these brand names:
{', '.join(names_to_validate)}

Check:
1. Domain availability (.com, .ai, .io)
2. Trademark conflicts
3. SEO potential
4. Search result analysis

Return validation results in JSON format.
"""

    import asyncio

    async def run_validation():
        events = await validation_runner.run_debug(
            user_messages=validation_prompt,
            quiet=not args.verbose,
            verbose=args.verbose
        )
        return events

    events = asyncio.run(run_validation())

    # Extract validation results
    validation_output = None
    for event in events:
        if hasattr(event, 'content') and event.content:
            validation_output = event.content
            break

    if validation_output:
        session.set_validation_results({'raw_output': str(validation_output)})
        print("âœ“ Validation complete\n")
    else:
        print("âœ— Validation failed\n")
        return

    # Save session
    get_session_manager().save_session(session)

    print("=" * 70)
    print("âœ“ VALIDATION COMPLETE")
    print("=" * 70)
    print(f"\nSession: {session.session_id}")
    print(f"\nNext steps:")
    print(f"  1. View validation results:")
    print(f"     python -m src.cli_interactive show --session {session.session_id}\n")
    print(f"  2. Choose your path:\n")
    print(f"     Option A: Generate brand story for a validated name")
    print(f"       python -m src.cli_interactive story \\")
    print(f"         --session {session.session_id} \\")
    print(f"         --name \"YourChosenName\"\n")
    print(f"     Option B: Not satisfied? Generate more names with feedback")
    print(f"       python -m src.cli_interactive feedback \\")
    print(f"         --session {session.session_id} \\")
    print(f"         --feedback \"Try a different approach...\"")
    print()


def cmd_story(args, session: BrandSessionState, config: Dict[str, str]) -> None:
    """
    Generate brand story for selected name.

    Args:
        args: Command arguments
        session: Session state
        config: Environment config
    """
    print("\n" + "=" * 70)
    print("GENERATE BRAND STORY")
    print("=" * 70 + "\n")

    print(f"Creating brand story for: {args.name}\n")

    product_info = session.get_product_info()

    # Run story agent
    print("Generating brand story, taglines, and value proposition...")
    story_agent = create_story_agent()
    story_runner = InMemoryRunner(agent=story_agent)

    story_prompt = f"""
Create a complete brand story for:

Brand Name: {args.name}
Product: {product_info.get('product', 'Unknown')}
Personality: {product_info.get('personality', 'Unknown')}
Industry: {product_info.get('industry', 'Unknown')}

Generate:
1. Five tagline options (5-8 words each, memorable and action-oriented)
2. Brand story (200-300 words)
3. Value proposition statement (20-30 words, clear and compelling)

Return in JSON format.
"""

    import asyncio

    async def run_story():
        events = await story_runner.run_debug(
            user_messages=story_prompt,
            quiet=not args.verbose,
            verbose=args.verbose
        )
        return events

    events = asyncio.run(run_story())

    # Extract story
    story_output = None
    for event in events:
        if hasattr(event, 'content') and event.content:
            story_output = event.content
            break

    if story_output:
        session.set_brand_story({'brand_name': args.name, 'raw_output': str(story_output)})
        print("âœ“ Brand story complete\n")
    else:
        print("âœ— Story generation failed\n")
        return

    # Save session
    get_session_manager().save_session(session)

    print("=" * 70)
    print("âœ“ BRAND IDENTITY COMPLETE")
    print("=" * 70)
    print(f"\nSession: {session.session_id}")
    print(f"Final Brand: {args.name}")
    print(f"\nWorkflow complete! Review session for full brand identity.")
    print()


def cmd_show(args, session: BrandSessionState) -> None:
    """
    Show generated names and results.

    Args:
        args: Command arguments
        session: Session state
    """
    import json

    print("\n" + "=" * 70)
    print(f"SESSION: {session.session_id}")
    print("=" * 70 + "\n")

    product_info = session.get_product_info()
    print(f"Product: {product_info.get('product', 'N/A')}")
    print(f"Step: {session.get_current_step()}")
    print()

    generated_names = session.get_generated_names()

    if not generated_names:
        print("No names generated yet.")
        print()
        return

    if args.format == 'json':
        # JSON format - output raw session data
        print(json.dumps(generated_names, indent=2))
        print()
        return

    # Simple or detailed format
    print(f"GENERATED NAMES ({len(generated_names)} total)")
    print("-" * 70 + "\n")

    for idx, name_entry in enumerate(generated_names, 1):
        if args.format == 'simple':
            # Show the full raw output
            raw_output = name_entry.get('raw_output', '')
            print(f"Batch {idx}:")
            print(raw_output)
            print()
        else:
            # Detailed format
            print(f"Batch {idx}:")
            print(json.dumps(name_entry, indent=2))
            print()

    # Show validation results if available
    validation_results = session.get_validation_results()
    if validation_results:
        print("=" * 70)
        print("VALIDATION RESULTS")
        print("-" * 70 + "\n")
        raw_output = validation_results.get('raw_output', '')
        print(raw_output)
        print()

    # Show brand story if available
    brand_story = session.get_brand_story()
    if brand_story:
        print("=" * 70)
        print("BRAND STORY")
        print("-" * 70 + "\n")
        print(f"Brand Name: {brand_story.get('brand_name', 'N/A')}")
        print()
        raw_output = brand_story.get('raw_output', '')
        print(raw_output)
        print()

    # Show next steps based on current workflow state
    print("=" * 70)
    print("NEXT STEPS")
    print("=" * 70 + "\n")

    current_step = session.get_current_step()

    if current_step == 'names_generated':
        print("You have generated names! Choose your next action:\n")
        print(f"  Option 1: Provide feedback and regenerate")
        print(f"    python -m src.cli_interactive feedback \\")
        print(f"      --session {session.session_id} \\")
        print(f"      --feedback \"I like names that emphasize [theme]\" \\")
        print(f"      --keep \"Name1,Name2\"\n")
        print(f"  Option 2: Validate selected names")
        print(f"    python -m src.cli_interactive validate \\")
        print(f"      --session {session.session_id} \\")
        print(f"      --names \"Name1,Name2,Name3\"\n")

    elif current_step == 'validated':
        print("Names have been validated! Choose your next action:\n")
        print(f"  Option 1: Generate more names (start over with context)")
        print(f"    python -m src.cli_interactive feedback \\")
        print(f"      --session {session.session_id} \\")
        print(f"      --feedback \"Try different approach...\"\n")
        print(f"  Option 2: Create brand story for chosen name")
        print(f"    python -m src.cli_interactive story \\")
        print(f"      --session {session.session_id} \\")
        print(f"      --name \"YourChosenName\"\n")

    elif current_step == 'story_generated':
        print("âœ… Brand identity complete!\n")
        print(f"  Review all results:")
        print(f"    python -m src.cli_interactive show --session {session.session_id}\n")
        print(f"  Start a new brand:")
        print(f"    python -m src.cli_interactive generate --session new-session ...\n")

    else:
        print("Start by generating names:\n")
        print(f"  python -m src.cli_interactive generate \\")
        print(f"    --session {session.session_id} \\")
        print(f"    --product \"Your product description\" \\")
        print(f"    --personality innovative \\")
        print(f"    --industry \"Your industry\"\n")


def cmd_status(args, session: BrandSessionState) -> None:
    """Show session status."""
    print("\n" + "=" * 70)
    print(f"SESSION STATUS: {session.session_id}")
    print("=" * 70 + "\n")

    print(f"Current Step: {session.get_current_step()}")
    print(f"Created: {session.state.get('created_at', 'Unknown')}")
    print(f"Updated: {session.state.get('updated_at', 'Unknown')}")
    print()

    product_info = session.get_product_info()
    if product_info:
        print("Product Info:")
        print(f"  Product: {product_info.get('product', 'N/A')}")
        print(f"  Personality: {product_info.get('personality', 'N/A')}")
        print(f"  Industry: {product_info.get('industry', 'N/A')}")
        print()

    generated_names = session.get_generated_names()
    print(f"Generated Names: {len(generated_names)} batches")

    feedback_history = session.get_feedback_history()
    print(f"Feedback Rounds: {len(feedback_history)}")

    selected_names = session.get_selected_names()
    if selected_names:
        print(f"Selected for Validation: {', '.join(selected_names)}")

    print()
    print(f"ðŸ’¡ Tip: Use 'python -m src.cli_interactive show --session {session.session_id}' to view names")
    print()


def cmd_list() -> None:
    """List all sessions."""
    session_manager = get_session_manager()
    sessions = session_manager.list_sessions()

    print("\n" + "=" * 70)
    print("ALL SESSIONS")
    print("=" * 70 + "\n")

    if not sessions:
        print("No sessions found.")
        print()
        return

    for session_id in sessions:
        session = session_manager.load_session(session_id)
        if session:
            step = session.get_current_step()
            updated = session.state.get('updated_at', 'Unknown')
            print(f"  {session_id}")
            print(f"    Step: {step}")
            print(f"    Updated: {updated}")
            print()


def cmd_delete(args, session: BrandSessionState) -> None:
    """Delete session."""
    session_manager = get_session_manager()

    print(f"\nDeleting session: {session.session_id}")
    session_manager.delete_session(session.session_id)
    print("âœ“ Session deleted\n")


def main():
    """Main CLI entry point."""
    parser = create_parser()
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    try:
        # Load config
        config = load_config()

        # Handle commands that don't need sessions
        if args.command == 'list':
            cmd_list()
            sys.exit(0)

        # All other commands need a session
        session_manager = get_session_manager()
        session = session_manager.get_or_create_session(args.session)

        # Route to command handlers
        if args.command == 'generate':
            cmd_generate(args, session, config)
        elif args.command == 'feedback':
            cmd_feedback(args, session, config)
        elif args.command == 'validate':
            cmd_validate(args, session, config)
        elif args.command == 'story':
            cmd_story(args, session, config)
        elif args.command == 'show':
            cmd_show(args, session)
        elif args.command == 'status':
            cmd_status(args, session)
        elif args.command == 'delete':
            cmd_delete(args, session)
        else:
            print(f"Unknown command: {args.command}")
            sys.exit(1)

        sys.exit(0)

    except Exception as e:
        print(f"\nâœ— Error: {e}")
        if args.verbose if hasattr(args, 'verbose') else False:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
